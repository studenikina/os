Страница курса - http://neerc.ifmo.ru/~os/y2014/index.html


HW -1
Обзавестись какой-нибудь Unix-like системой.

HW 0
Написать на языке C программу, печатающую "Hello, world!" (с переводом строки в конце).

Файлы в репозитории

/hello_world/hello_world.c
/hello_world/Makefile
Скриптом сборки генерируется

/hello_world/hello_world
Hints

man 3 printf
Убедитесь, что повторный вызов make ничего не делает
Убедитесь, что make clean удаляет всё, что создал make

HW 1
Необходимо реализовать примитивный вариант утилиты cat, копирующий символы из stdin на stdout. Для реализации ввода-вывода нужно пользоваться системными вызовами  read и write. Функциями из stdio.h (printf, getchar, putchar, ...) можно пользоваться только для вывода отладочной информации и/или сообщений об ошибках.

Файлы в репозитории

/cat/cat.c
/cat/Makefile
Скриптом сборки генерируется

/cat/cat
Hints

man 2 read
man 2 write
Пример работы

./cat < cat.c > cat2.c && diff cat.c cat2.c && echo OK
curl neerc.ifmo.ru/~os/blob.bin | ./cat > blob.bin && curl neerc.ifmo.ru/~os/blob.bin > blob2.bin && diff blob.bin blob2.bin && echo OK (осторожно, 2×5Mb)

HW 2
Необходимо реализовать скрипт для командной оболочки bash, обходящий указанную директорию и выводящий список файлов, изменённых более недели назад и являющихся символьными ссылками, которые ссылаются на несуществующий файл. Директория, которую нужно обойти, указана первым аргументом командной строки.

Найденные файлы можно выводить в любом порядке. Пути до файлов можно выводить в любом корректном формате. Например, все следующие варианты допустимы и являются путями до одного и того же файла: a/b/c/d, ./a//b/c/d, a/../a/b/c/d.

Файлы в репозитории

/badlinks/badlinks.sh
Hints

man 1 test
man 1 bash
Advanced Bash-Scripting Guide
Пример работы

Скрипт создаст директорию hw2-example. Запуск ./badlinks.sh hw2-example должен вывести:

$ ./badlinks.sh hw2-example
hw2-example/bad-old-link
hw2-example/nested/bad-old-link2
hw2-example/link-to-nested/bad-old-link2

HW 3
Реализовать программу, в течение 10 секунд ожидающую SIGUSR1 или SIGUSR2 и печатающую информацию о полученном сигнале в формате "<имя сигнала> from <pid>". Здесь <имя сигнала> — SIGUSR1 или SIGUSR2, а <pid> — номер процесса, от которого пришёл сигнал. Если никакой сигнал не пришёл, вывести No signals were caught. Если пришло несколько сигналов, вывести информацию только про какой-либо один из них.

Файлы в репозитории

/sigusr/sigusr.c
/sigusr/Makefile
Скриптом сборки генерируется

/sigusr/sigusr
Hints

man 7 signal
man 2 sigaction
man 1 kill
man 2 kill
man 3 sleep или man 2 alarm
signal(2) — не тот системный вызов, который вы ищете
Внимательно изучить, что, теоретически, может пойти не так:
Что, если сигнал прилетает во время обработки другого сигнала?
Что, если сигнал прилетает сразу перед/после printf-а?
Пример работы

$ ./sigusr > tmp & sleep 2; kill -SIGUSR1 $!; wait; cat tmp
SIGUSR1 from <pid>
$ ./sigusr
No signals were caught

HW 4
Описание задачи

Вам требуется написать упрощённую версию командного интерпретатора. Он будет считывать со стандартного ввода команду, выполнять её, дожидаться её завершения, и повторять сначала.

Команда --- это строка, заканчивающаяся символом перевода строки. Эту строку нужно разбить по символу "|" на подкоманды. Каждую подкоманду нужно разбить по пробелу на имя и аргументы, и запустить. Стандартный вывод первой подкоманды нужно перенаправить на стандартный ввод второй, стандартный вывод второй --- на стандартный ввод третьей, ... Стандартный ввод для первой подкоманды совпадает со стандартным вводом командного интерпретатора, стандартный вывод последней --- со стандартным выводом интерпретатора.

Если ввод кончился, интерпретатор должен завершиться. Если интерпретатору прилетел SIGINT (ctrl+C), то он должен быть перепослан запущенной команде.

Для наглядности, печатайте приглашение $ тогда, когда можно вводить команду.

Файлы в репозитории

/simplesh/simplesh.c
/simplesh/Makefile
Скриптом сборки генерируется

/simplesh/simplesh
Пример использования

host$ ./simplesh
> $
< ls
> <содержимое директории>
> $
< cat /proc/cpuinfo | grep model | grep name | sed -re s/.*:\s(.*)/\1/ | uniq
> <модель процессора>
> $
< ^D
< и > символизируют ввод и вывод и показаны исключительно для наглядности.

host$ ./simplesh
> $
< cat | wc -l
< first line
< second line
< third line
< ^D
> 3
> $
< cat|wc -l
< first
< second
< third
< ^D
> 3
> $
< ^D
Запуск cat | sleep 1 | cat должен вести себя так же, как при запуске в обычном шелле: точно так же реагировать на ввод, столько же работать и не плодить зомби-процессы. То же относится к sleep 15 | sleep 1 | sleep 15.

Проверка того, что команда считывается правильно: (echo -ne l; sleep 1; echo s) | ./simplesh (запускать в настоящем шелле, а не в реализуемом) должно показывать содержимое текущей директории.

Уметь объяснять, что происходит при запуске echo -ne "cat\nhello" | ./simplesh и мотивировать, почему именно это - правильное поведение.

yes date | ./simplesh должно выводить бесконечно много раз текущее время.

(echo md5sum; sleep 1; dd if=/dev/zero bs=1024 count=100000) | ./simplesh должно печатать, среди прочего, 75a1e608e6f1c50758f4fee5a7d8e3d0.

Технические детали

Весь ввод-вывод требуется реализовывать самостоятельно с помощью read и write.
Ввод-вывод необходимо делать оптимально: если в буфере лежит команда длины n целиком, она должна быть прочитана с помощью одного вызова read вместо n вызовов.
Код должен работать в одном потоке и создавать по новому процессу на каждую подкоманду. Дополнительные процессы не должны создаваться.
Можно использовать C++ (контейнеры, лямбды, ...).
Код нужно выложить в директорию /simplesh своего репозитория.
Что не забыть проверить

Команда может не влезть в один read
read, читающий команду, может считать начало входных данных команды
